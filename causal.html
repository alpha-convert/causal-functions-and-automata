<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Transducers are Causal Functions</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.16.0+0.16.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="transducers-are-causal-functions">
<h1 class="title">Transducers are Causal Functions</h1>

<p>Consider the set <span class="math">\(2^\omega\)</span> of infinite lists of natural numbers. What are the &quot;nice&quot; functions <span class="math">\(2^\omega \to 2^\omega\)</span>? 
As indicated by the quotes, the answer to this question is highly dependent on your aesthetic preferences.
Naturally, different people with different needs have proposed different answers based on a wide variety of values of &quot;nice&quot;.</p>
<p>One potential value of &quot;nice&quot; is the vacuous one: all (mathematically definable) functions <span class="math">\(2^\omega \to 2^\omega\)</span> are allowed!
Among these are functions that aren't even definable as functions in your favorite programming language,
such as the function <span class="math">\(f : 2^\omega \to 2^\omega\)</span> defined by <span class="math">\(f(1^\omega) = 0^\omega\)</span> and  <span class="math">\(f(s) = s\)</span>: the function
which is the identity everywhere, except for on the stream of all ones, where it's the stream of all zeroes.
This function is clearly not computable in any sense: in order to determine even the first element of the output stream,
all infinitely-many elements of the input need to be inspected.</p>
<p>Restricting &quot;nice&quot; to mean &quot;computable&quot; restricts the class significantly. Indeed, the main result is 
the rule out functions like the one above. A classic result in computability theory is that the computable
functions <span class="math">\(f : 2^\omega \to 2^\omega\)</span> are <em>continous</em> in a particular sense <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a> which means that any finite prefix
of the output of <span class="math">\(f\)</span> can only depend on a finite prefix of its input.</p>
<p>However, the computable functions can include some unwanted behavior. Of particular interest for the purposes of this
piece is functions that &quot;go back on their word&quot;.
A simple example of this is the function defined by the equations <span class="math">\(f(00s) = 01s\)</span>, <span class="math">\(f(01s) = 10s\)</span>, <span class="math">\(f(1s) = 1s\)</span>.
To see why this might be undesierable, consider a situation where the input list to the function is being <em>streamed in</em>, bit by bit, from
some outside source. Similarly, suppose the output is being produced bit by bit, and is fed to some similar transformation down the line.
Unfortunately, the function <span class="math">\(f\)</span> cannot be implemented in this manner: if the first bit of input is a <span class="math">\(0\)</span>,
the implementation must wait until the <em>second</em> bit arrives to emit the first bit of output. To faithfully implement this
in such a &quot;stream transformer&quot; machine model, the machine would need the ability to either (a) block until the second bit arrives, or
(b) emit a dummy value for the first output and then &quot;retract&quot; it once it got the second bit of input.</p>
<p>Our goal in this document is to characterize the stream functions <span class="math">\(f : 2^\omega \to 2^\omega\)</span> which
can be implemented as stream processing machines which are both (a) &quot;productive&quot;, in the sense that they always
emit an output for each input, and (b) are &quot;truthful&quot; in the sense that they never have to go back on their word.</p>
<p>To begin, let's define a cobinductive <a class="footnote-reference" href="#footnote-2" id="footnote-reference-2">[2]</a>. type of streams, with elements drawn from a type <code class="highlight coq"><span class="n">A</span></code>.
This type is generated by one constructor, <code class="highlight coq"><span class="n">SCons</span></code>, which means that every stream <code class="highlight coq"><span class="n">s</span></code> is equal to
<code class="highlight coq"><span class="n">SCons</span> <span class="n">x</span> <span class="n">s'</span></code>, where <code class="highlight coq"><span class="n">x</span></code> is an element of type <code class="highlight coq"><span class="n">A</span></code> (the &quot;head&quot; of the stream), and <code class="highlight coq"><span class="n">s'</span></code> is another stream.
The circularity of this definition combined with the lack of a <code class="highlight coq"><span class="n">SNil</span></code> constructor means that all
values of type <code class="highlight coq"><span class="n">stream</span> <span class="n">A</span></code> are infinite.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">stream</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
| SCons : A -&gt; stream A -&gt; stream A.</span></span></pre><p>More or less by definition, the functions <code class="highlight coq"><span class="n">stream</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">stream</span> <span class="n">B</span></code> which can be written in Coq
are computable. Unfortunately, we must work a bit harder to get the other properties.</p>
<p>Intuitively, both the truthfulness and productivity properties are facts about <em>prefixes</em> of streams.
Truthfulness says that passing a larger prefix yields only a larger output, while productivity says
precisely by how much the output should grow. Of course, while this makes intuitive sense, it's not
immediately clear how to define these properties formally. After all, stream functions <code class="highlight coq"><span class="n">f</span> <span class="o">:</span> <span class="n">stream</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">stream</span> <span class="n">B</span></code>
are defined on <em>entire</em> streams, not prefixes!</p>
<p>The insight required to guide us past this quandry is that truthful, productive functions on prefixes of streams
should actually be defined <em>in terms of</em> functions on their prefixes. To investigate this idea further, let's
introduce a type of prefixes.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">vec</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : nat -&gt; <span class="kt">Type</span> :=
| Empty : vec A <span class="mi">0</span>
| Snoc {n} : vec A n -&gt; A -&gt; vec A (S n).</span></span></pre><p>Above is a definition of length-indexed vectors, represented as snoc-lists.
These will represent prefixes of streams.</p>
<p>The most important (for our purposes) operation on vectors is truncation: deleting the
last element. Because we've implemented vectors as length-indexed snoc lists,
truncate is trivial to implment, as shown below.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">truncate</span> {<span class="nv">A</span>} {<span class="nv">n</span> : nat} (<span class="nv">l</span> : vec A (S n)) : vec A n := 
  <span class="kr">match</span> l <span class="kr">in</span> vec _ (S n) <span class="kr">return</span> vec A n <span class="kr">with</span>
  | Snoc _ l _ =&gt; l
  <span class="kr">end</span>.</span></span></pre><p>We will also need the two &quot;standard&quot; list functions <code class="highlight coq"><span class="n">tail</span></code> and <code class="highlight coq"><span class="n">cons</span></code>, as well as some theorems relating them to <code class="highlight coq"><span class="n">Snoc</span></code> and <code class="highlight coq"><span class="n">truncate</span></code>.
Rather than take time to explain these later, we will simply introduce them here.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">cons</span> {<span class="nv">A</span>} {<span class="nv">n</span> : nat} (<span class="nv">x</span> : A) (<span class="nv">l</span> : vec A n) : vec A (S n) :=
  <span class="kr">match</span> l <span class="kr">in</span> vec _ n <span class="kr">return</span> vec _ (S n) <span class="kr">with</span>
  | Empty _ =&gt; Snoc _ (Empty _) x
  | Snoc _ l&#39; y =&gt; Snoc _ (cons x l&#39;) y
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk0"><span class="kn">Definition</span> <span class="nf">tail</span> {<span class="nv">A</span>} {<span class="nv">n</span> : nat} (<span class="nv">l</span> : vec A (S n)) : vec A n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vec A n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk1"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vec A <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="causal-v-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S (S n))</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>vec A (S n) -&gt; vec A n</span></span></span><br></div><label class="goal-separator" for="causal-v-chk2"><hr></label><div class="goal-conclusion">vec A (S n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vec A <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Empty A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S (S n))</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>vec A (S n) -&gt; vec A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vec A (S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk5"><span class="nb">inversion</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S (S n))</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>vec A (S n) -&gt; vec A n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>vec A (S n)</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n0 = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vec A (S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk6"><span class="nb">apply</span> (<span class="kr">fun</span> <span class="nv">u</span> =&gt; Snoc _ u X0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S (S n))</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>vec A (S n) -&gt; vec A n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>vec A (S n)</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n0 = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vec A n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk7"><span class="nb">apply</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S (S n))</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>vec A (S n) -&gt; vec A n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>vec A (S n)</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n0 = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vec A (S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Basics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Program.Equality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk8"><span class="kn">Theorem</span> <span class="nf">cons_snoc</span> {<span class="nv">A</span>} : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">l</span> : vec A n) <span class="nv">x</span> <span class="nv">y</span>, cons x (Snoc _ l y) = Snoc _ (cons x l) y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A n) (<span class="nv">x</span> <span class="nv">y</span> : A),
cons x (Snoc A l y) = Snoc A (cons x l) y</div></blockquote></div></div></small><span class="alectryon-wsp">  
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A n) (<span class="nv">x</span> <span class="nv">y</span> : A),
cons x (Snoc A l y) = Snoc A (cons x l) y</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chka"><span class="nb">intros</span> n l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
cons x (Snoc A l y) = Snoc A (cons x l) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chkb"><span class="nb">dependent destruction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
cons x (Snoc A (Empty A) y) =
Snoc A (cons x (Empty A)) y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="causal-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="causal-v-chkc"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
cons x (Snoc A (Snoc A l a) y) =
Snoc A (cons x (Snoc A l a)) y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
cons x (Snoc A (Empty A) y) =
Snoc A (cons x (Empty A)) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chke"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
Snoc A (Snoc A (Empty A) x) y =
Snoc A (Snoc A (Empty A) x) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chkf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
cons x (Snoc A (Snoc A l a) y) =
Snoc A (cons x (Snoc A l a)) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk10"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cons x (Snoc A (Snoc A l a) y) =
Snoc A (cons x (Snoc A l a)) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk11"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Snoc A (Snoc A (cons x l) a) y =
Snoc A (Snoc A (cons x l) a) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk12"><span class="kn">Theorem</span> <span class="nf">truncate_cons</span> {<span class="nv">A</span>} : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">l</span> : vec A (S n)) <span class="nv">x</span>, truncate (cons x l) = cons x (truncate l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A (S n)) (<span class="nv">x</span> : A),
truncate (cons x l) = cons x (truncate l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A (S n)) (<span class="nv">x</span> : A),
truncate (cons x l) = cons x (truncate l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk14"><span class="nb">intros</span> n l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
truncate (cons x l) = cons x (truncate l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk15"><span class="nb">dependent induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S n0)),
n = S n0 -&gt;
l ~= l0 -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, truncate (cons x l0) = cons x (truncate l0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
truncate (cons x (Snoc A l a)) =
cons x (truncate (Snoc A l a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S n0)),
n = S n0 -&gt;
l ~= l0 -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, truncate (cons x l0) = cons x (truncate l0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
truncate (cons x (Snoc A l a)) =
cons x (truncate (Snoc A l a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk17"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S n0)),
n = S n0 -&gt;
l ~= l0 -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, truncate (cons x l0) = cons x (truncate l0)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">truncate (cons x (Snoc A l a)) =
cons x (truncate (Snoc A l a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk18"><span class="nb">rewrite</span> cons_snoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S n0)),
n = S n0 -&gt;
l ~= l0 -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, truncate (cons x l0) = cons x (truncate l0)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">truncate (Snoc A (cons x l) a) =
cons x (truncate (Snoc A l a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk19"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S n0)),
n = S n0 -&gt;
l ~= l0 -&gt; <span class="kr">forall</span> <span class="nv">x</span> : A, truncate (cons x l0) = cons x (truncate l0)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cons x l = cons x l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk1a"><span class="kn">Theorem</span> <span class="nf">tail_snoc</span> {<span class="nv">A</span>} : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A (S n)) <span class="nv">x</span>, tail (Snoc _ l x) = Snoc _ (tail l) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A (S n)) (<span class="nv">x</span> : A),
tail (Snoc A l x) = Snoc A (tail l) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk1b"><span class="kn">Theorem</span> <span class="nf">truncate_tail</span> {<span class="nv">A</span>} : <span class="kr">forall</span> <span class="nv">n</span> (<span class="nv">l</span> : vec A (S (S n))) , truncate (tail l) = tail (truncate l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A (S (S n))),
truncate (tail l) = tail (truncate l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk1c"><span class="nb">intros</span> n l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S (S n))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">truncate (tail l) = tail (truncate l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk1d"><span class="nb">dependent induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S n)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S (S n0))),
S n = S (S n0) -&gt; l ~= l0 -&gt; truncate (tail l0) = tail (truncate l0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">truncate (tail (Snoc A l a)) =
tail (truncate (Snoc A l a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk1e"><span class="nb">dependent destruction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S (S n0))),
S n = S (S n0) -&gt; Snoc A l a ~= l0 -&gt; truncate (tail l0) = tail (truncate l0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">truncate (tail (Snoc A (Snoc A l a) a0)) =
tail (truncate (Snoc A (Snoc A l a) a0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk1f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n0</span> : nat) (<span class="nv">l0</span> : vec A (S (S n0))),
S n = S (S n0) -&gt; Snoc A l a ~= l0 -&gt; truncate (tail l0) = tail (truncate l0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_rect (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; vec A (S n) -&gt; vec A n)
  (<span class="kr">fun</span> <span class="nv">_</span> : vec A <span class="mi">1</span> =&gt; Empty A)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">IHn</span> : vec A (S n) -&gt; vec A n)
     (<span class="nv">l</span> : vec A (S (S n))) =&gt;
   <span class="kr">match</span>
     l <span class="kr">in</span> (vec _ n0)
     <span class="kr">return</span> (n0 = S (S n) -&gt; vec A (S n))
   <span class="kr">with</span>
   | Empty _ =&gt;
       <span class="kr">fun</span> <span class="nv">H</span> : <span class="mi">0</span> = S (S n) =&gt;
       False_rect (vec A (S n))
         (eq_ind <span class="mi">0</span>
            (<span class="kr">fun</span> <span class="nv">e</span> : nat =&gt;
             <span class="kr">match</span> e <span class="kr">with</span>
             | <span class="mi">0</span> =&gt; <span class="kt">True</span>
             | S _ =&gt; <span class="kt">False</span>
             <span class="kr">end</span>) I (S (S n)) H)
   | @Snoc _ n0 x x0 =&gt;
       <span class="kr">fun</span> <span class="nv">H</span> : S n0 = S (S n) =&gt;
       eq_rect_r
         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt; vec A n1 -&gt; A -&gt; vec A (S n))
         (<span class="kr">fun</span> (<span class="nv">X</span> : vec A (S n)) (<span class="nv">X0</span> : A) =&gt;
          Snoc A (IHn X) X0)
         (<span class="nb">f_equal</span>
            (<span class="kr">fun</span> <span class="nv">e</span> : nat =&gt;
             <span class="kr">match</span> e <span class="kr">with</span>
             | <span class="mi">0</span> =&gt; n0
             | S n1 =&gt; n1
             <span class="kr">end</span>) H) x x0
   <span class="kr">end</span> eq_refl) n (Snoc A l a) = tail (Snoc A l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>Truncation is particularly interesting because it lets us reframe streams in terms of their prefixes.
A stream can be thought of as a family of vectors <code class="highlight coq"><span class="n">vs</span> <span class="o">:</span> <span class="kr">forall</span> <span class="nv">n</span><span class="o">,</span> <span class="n">vec</span> <span class="n">n</span></code>, one of each length,
such that the <span class="math">\(n+1\)</span> st is just the <span class="math">\(n\)</span> th with one element tacked on to the end.
Swapping the perspective around, this is to say that that <code class="highlight coq"><span class="n">vs</span> <span class="n">n</span> <span class="o">=</span> <span class="n">truncate</span> <span class="o">(</span><span class="n">vs</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span></code>.
Intuitively, this view of streams is consistent with their view as coinductively defined objects:
they are lists that we may unfold to any finite depth.</p>
<div class="section" id="causal-functions">
<h1>Causal Functions</h1>
<p>Viewing streams this way leads us to our first definition of productive &amp; truthful functions on streams!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">causal</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> := mkCausal {
  f : <span class="kr">forall</span> <span class="nv">n</span>, vec A n -&gt; vec B n;
  caused : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>, f n (truncate l) = truncate (f (S n) l)
}.</span></span></pre><p>For historical reasons, these objects are called &quot;causal functions&quot;, which consist of</p>
<blockquote>
<ol class="arabic simple">
<li>A family of maps <code class="highlight coq"><span class="n">f</span> <span class="n">n</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">A</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">vec</span> <span class="n">B</span> <span class="n">n</span></code> taking <code class="highlight coq"><span class="n">A</span></code>-vectors of length <code class="highlight coq"><span class="n">n</span></code> to <code class="highlight coq"><span class="n">B</span></code>-vectors of length <code class="highlight coq"><span class="n">n</span></code>.
For a causal function <code class="highlight coq"><span class="n">c</span></code> and some nat <code class="highlight coq"><span class="n">m</span></code>, we will call <code class="highlight coq"><span class="n">f</span> <span class="n">c</span> <span class="n">m</span></code> the <code class="highlight coq"><span class="n">m</span></code>-th component of <code class="highlight coq"><span class="n">c</span></code>.
The typing of these components ensures the &quot;one-at-a-time&quot; productivity of this family, viewed as a stream function.
Vectors of length 1 yield vectors of length 1, and adding one more element to the input yields
exactly one more element of output. But nothing in the type ensures that the first elmement
remained the same. That's the job of the second component of the record, which consists of...</li>
<li>Proofs that the family <code class="highlight coq"><span class="n">f</span></code> &quot;commutes with truncation&quot;, as shown in the commutative diagram below.
Intuitively, <code class="highlight coq"><span class="n">f</span> <span class="n">n</span> <span class="o">(</span><span class="n">truncate</span> <span class="n">l</span><span class="o">)</span> <span class="o">=</span> <span class="n">truncate</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span></code> says that <code class="highlight coq"><span class="n">f</span> <span class="n">n</span></code> and <code class="highlight coq"><span class="n">f</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)</span></code> must agree on the
first <code class="highlight coq"><span class="n">n</span></code> elements of their input: only the final element of <code class="highlight coq"><span class="n">f</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)</span></code> can be &quot;new&quot;.</li>
</ol>
</blockquote>
<img alt="square.png" src="square.png" style="width: 50%;" />
<p>Gluing all of these squares together, the data of a causal function is contained in the
following diagram: a pair of infinitely descending chains, connected pointwise
by the components of <code class="highlight coq"><span class="n">f</span></code>.</p>
<img alt="causal-presheaf-diagram.png" src="causal-presheaf-diagram.png" style="width: 75%;" />
<p>To the observer trained in the arts of category theory, this may spark some recognition:
<code class="highlight coq"><span class="n">vec</span></code> is &quot;just&quot; an <span class="math">\(\omega\)</span>-presheaf, and causal functions are &quot;just&quot; presheaf morphisms.</p>
<p>Now with our definition of causal functionns in hand, it's time to interpret causal functions as stream functions, i.e. turn a causal map
that operates on finite prefixes of a stream into one that transforms whole streams.</p>
<p>To begin, we note that causal maps naturally act as functions <code class="highlight coq"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code> by considering the <code class="highlight coq"><span class="n">f</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">vec</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">vec</span> <span class="mi">1</span></code> component as a map on
singleton lists.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk20"><span class="kn">Definition</span> <span class="nf">causalApply1</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">c</span> : causal A B) (<span class="nv">x</span> : A) : B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>causal A B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>This should allow us to lift a causal function from <code class="highlight coq"><span class="n">A</span></code> to <code class="highlight coq"><span class="n">B</span></code> to a function from streams of <code class="highlight coq"><span class="n">A</span></code>-s
to streams of <code class="highlight coq"><span class="n">B</span></code>-s.
Intuitively, the process is straightforward. Given a causal function <code class="highlight coq"><span class="n">c</span></code>,
we will define its interpreation as a stream map <code class="highlight coq"><span class="n">interpCausal</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stream</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">stream</span> <span class="n">B</span></code> as the
function which takes a stream <code class="highlight coq"><span class="n">SCons</span> <span class="n">x</span> <span class="n">s</span></code>, and returns the stream <code class="highlight coq"><span class="n">SCons</span> <span class="n">y</span> <span class="n">s'</span></code>,
where <code class="highlight coq"><span class="n">y</span></code> is the result of using <code class="highlight coq"><span class="n">c</span></code> as a function <code class="highlight coq"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code> and passing <code class="highlight coq"><span class="n">x</span></code>, and <code class="highlight coq"><span class="n">s'</span></code> is the
result of the recursive call.</p>
<p>This intuitive idea is translated into code below.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">interpCausalWrong</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">c</span> : causal A B) (<span class="nv">s</span> : stream A) : stream B :=
  <span class="kr">match</span> s <span class="kr">with</span>
  | SCons _ x s =&gt; <span class="kr">let</span> <span class="nv">y</span> := causalApply1 c x <span class="kr">in</span>
                   SCons _ y (interpCausalWrong c s)
  <span class="kr">end</span>.</span></span></pre><p>Unfortunately, as the identifier suggests, this is wrong in an important way.
To understand why, consider the stream <code class="highlight coq"><span class="n">SCons</span> <span class="n">x</span> <span class="o">(</span><span class="n">SCons</span> <span class="n">y</span> <span class="n">s</span><span class="o">)</span></code>. The function <code class="highlight coq"><span class="n">interpCausalWrong</span></code>
sends this to <code class="highlight coq"><span class="n">SCons</span> <span class="n">x'</span> <span class="o">(</span><span class="n">SCons</span> <span class="n">y'</span> <span class="n">s'</span><span class="o">)</span></code>, with <code class="highlight coq"><span class="n">x'</span> <span class="o">=</span> <span class="n">causalApply1</span> <span class="n">c</span> <span class="n">x</span></code> and <code class="highlight coq"><span class="n">y'</span> <span class="o">=</span> <span class="n">causalApply1</span> <span class="n">c</span> <span class="n">y</span></code>.
Unfolding the definition of <code class="highlight coq"><span class="n">causalApply1</span></code>, this means that <code class="highlight coq"><span class="n">x'</span></code> and <code class="highlight coq"><span class="n">y'</span></code> are both the result of
applying the first component of <code class="highlight coq"><span class="n">c</span></code>.</p>
<p>However, we would expect the first two bits of the output be the results of applying the
2nd component of <code class="highlight coq"><span class="n">c</span></code> to the length-2 vector <code class="highlight coq"><span class="n">Snoc</span> <span class="o">(</span><span class="n">Snoc</span> <span class="n">x</span> <span class="n">Empty</span><span class="o">)</span> <span class="n">y</span></code>.</p>
<p>To fix this, we must shift our perspective. If we've processed <code class="highlight coq"><span class="n">n</span></code> elements of the stream so far,
We produce the <code class="highlight coq"><span class="n">n</span><span class="o">+</span><span class="mi">1</span></code>-st output by <code class="highlight coq"><span class="n">Snoc</span></code>-ing the <code class="highlight coq"><span class="n">n</span><span class="o">+</span><span class="mi">1</span></code>-st input onto the prior <code class="highlight coq"><span class="n">n</span></code>,
applying the <code class="highlight coq"><span class="n">n</span><span class="o">+</span><span class="mi">1</span></code>-st component of <code class="highlight coq"><span class="n">c</span></code>, and then taking the tail.
This process is encoded by the function <code class="highlight coq"><span class="n">causalApplySnoc</span></code> below.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">causalApplySnoc</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">n</span> : nat} (<span class="nv">c</span> : causal A B) (<span class="nv">l</span> : vec A n) (<span class="nv">x</span> : A) : B :=
  <span class="kr">match</span> f _ _ c (S n) (Snoc _ l x) <span class="kr">in</span> vec _ (S n) <span class="kr">return</span> B <span class="kr">with</span>
  | Snoc _ _ y =&gt; y
  <span class="kr">end</span>.</span></span></pre><p>We can now write <code class="highlight coq"><span class="n">interpCausal</span></code> by simply accumulating elements as we see them, and kicking the
whole process off with the empty stream.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">interpCausalAux</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">n</span> : nat} (<span class="nv">c</span> : causal A B) (<span class="nv">l</span> : vec A n) (<span class="nv">s</span> : stream A) : stream B :=
  <span class="kr">match</span> s <span class="kr">with</span>
  | SCons _ x s =&gt; <span class="kr">let</span> <span class="nv">y</span> := causalApplySnoc c l x <span class="kr">in</span>
                   SCons _ y (interpCausalAux c (Snoc _ l x) s)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">interpCausal</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">c</span> : causal A B) : stream A -&gt; stream B :=
  <span class="kr">fun</span> <span class="nv">s</span> =&gt; interpCausalAux c (Empty _) s.</span></span></pre><p>To our initual query of &quot;which are the nice functions&quot; <code class="highlight coq"><span class="n">stream</span> <span class="o">-&gt;</span> <span class="n">stream</span></code>,
<code class="highlight coq"><span class="n">interpCausal</span></code> provides the answer: &quot;those which arise as <code class="highlight coq"><span class="n">interpCausal</span> <span class="n">c</span></code> for some causal function <code class="highlight coq"><span class="n">c</span></code>&quot;.</p>
</div>
<div class="section" id="transducers">
<h1>Transducers</h1>
<p>As it turns out, causal functions are just one formalism for capturing this class of stream maps!
Another is by way of <em>transducers</em>, which are best thought of as stateful functions of type <code class="highlight coq"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span></code>.
More precisely, a transducer is a function that takes in an <code class="highlight coq"><span class="n">A</span></code>, and produces both an output <code class="highlight coq"><span class="n">B</span></code>, and a new transducer:
the new state. The coinductive definition below uses a single constructor <code class="highlight coq"><span class="n">T</span></code> to encode this:
every transducer <code class="highlight coq"><span class="n">t</span> <span class="o">:</span> <span class="n">transd</span></code> is of the form <code class="highlight coq"><span class="n">T</span> <span class="n">f</span></code>, where <code class="highlight coq"><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">*</span> <span class="n">transd</span></code> is a function
from an input <code class="highlight coq"><span class="n">A</span></code> to pair of an output <code class="highlight coq"><span class="n">B</span></code> and a new transducer to take the place of the old one.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">transd</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : <span class="kt">Type</span>): <span class="kt">Type</span> := 
| T : (A -&gt; B * transd A B) -&gt; transd A B.</span></span></pre><p>Of course, nothing in the type discipline prevents us from using the same <code class="highlight coq"><span class="n">f</span></code> multiple times
and ignoring the output <code class="highlight coq"><span class="n">transd</span></code>, so we will just have to be careful about not accidentally reusing stale states.</p>
<p>Because stepping the transducer requires a pattern match, we wrap this behavior in a function <code class="highlight coq"><span class="n">step</span> <span class="o">:</span> <span class="n">transd</span> <span class="n">A</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">*</span> <span class="o">(</span><span class="n">transd</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span></code>,
defined below.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">step</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">t</span> : transd A B) (<span class="nv">x</span> : A) : B * transd A B :=
    <span class="kr">match</span> t <span class="kr">with</span>
    | T _ _ f =&gt; f x
    <span class="kr">end</span>.</span></span></pre><p>To get a sense of how transducers work, let's define a transducer which computes the partial sums of its input.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">partialSumAux</span> (<span class="nv">n</span> : nat) : transd nat nat :=
  T _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">let</span> <span class="nv">y</span> := x + n <span class="kr">in</span> (y, partialSumAux y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">partialSum</span> : transd nat nat := partialSumAux <span class="mi">0</span>.</span></span></pre><p>This transducer accumulates a running total <code class="highlight coq"><span class="n">n</span></code> of the values it's seen so far. When it gets 
an input <code class="highlight coq"><span class="n">x</span></code>, it outputs <code class="highlight coq"><span class="n">x</span> <span class="o">+</span> <span class="n">n</span></code>, and transitions to a new state where the running total <em>is</em> <code class="highlight coq"><span class="n">x</span> <span class="o">+</span> <span class="n">n</span></code>.</p>
<p>With an illustative example in hand, we can start to look at ways of interpreting
transducers. Unlike last time, the natural thing works!
A transducer <code class="highlight coq"><span class="n">t</span></code> is interpreted as the function that, when given a stream <code class="highlight coq"><span class="n">SCons</span> <span class="n">x</span> <span class="n">s</span></code>,
steps <code class="highlight coq"><span class="n">t</span></code> on <code class="highlight coq"><span class="n">x</span></code>, producing output <code class="highlight coq"><span class="n">y</span></code> and a new transducer <code class="highlight coq"><span class="n">t'</span></code>, and returns the stream with <code class="highlight coq"><span class="n">y</span></code>
cons'd to the front of interpreting <code class="highlight coq"><span class="n">t'</span></code> on the rest of the stream.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">interpTransd</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">t</span> : transd A B) : stream A -&gt; stream B :=
  <span class="kr">fun</span> <span class="nv">s</span> =&gt;
    <span class="kr">match</span> s <span class="kr">with</span>
    | SCons _ x s =&gt; <span class="kr">let</span> (<span class="nv">y</span>,t&#39;) := step t x <span class="kr">in</span>
                     SCons _ y (interpTransd t&#39; s)
    <span class="kr">end</span>.</span></span></pre><p>The fact that stepping <code class="highlight coq"><span class="n">t</span></code> returns a new transducer ready to handle the rest of the stream
means we don't have to do any auxiliary state-passing: it's all handled by the
definition of the particular <code class="highlight coq"><span class="n">t</span></code>.</p>
<p><code class="highlight coq"><span class="n">interpTransd</span></code> provides yet another answer to the question of which functions <code class="highlight coq"><span class="n">stream</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">stream</span> <span class="n">B</span></code> are nice:
those which arise by <code class="highlight coq"><span class="n">interpTransd</span> <span class="n">t</span></code> for some transducer t!</p>
</div>
<div class="section" id="back-and-forth">
<h1>Back and Forth</h1>
<p>As it happens, the two answers we have discussed thus far seem to actually be the same: 
transducers and causal functions define the same class of stream morphisms.
The first step in showing this is to show that transducers and causal functions are inter-convertible:
we can turn one into the other, and vice versa. Surprisingly, both directions are straightforward.</p>
<p>We begin by showing that transducers can be interpreted as causal functions. Given a
transducer <code class="highlight coq"><span class="n">t</span></code>, the components of the corresponding causal function are the functions <code class="highlight coq"><span class="n">vec</span> <span class="n">A</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">vec</span> <span class="n">B</span> <span class="n">n</span></code>
which fold <code class="highlight coq"><span class="n">step</span> <span class="n">t</span></code> over the input vector from left to right, threading the updated state through.
This is implemented in the two functions below: <code class="highlight coq"><span class="n">stepN</span></code> handles the threading of the transducer through,
and <code class="highlight coq"><span class="n">execN</span></code> simply projects out the result.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">stepN</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">n</span>} (<span class="nv">t</span> : transd A B) (<span class="nv">l</span> : vec A n) : transd A B * vec B n :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | Empty _ =&gt; (t,Empty _)
    | Snoc _ l&#39; x =&gt; <span class="kr">let</span> (<span class="nv">t&#39;</span>,l&#39;&#39;) := stepN t l&#39; <span class="kr">in</span>
                     <span class="kr">let</span> (<span class="nv">y</span>,t&#39;&#39;) := step t&#39; x <span class="kr">in</span>
                     (t&#39;&#39;,Snoc _ l&#39;&#39; y)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">execN</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">t</span> : transd A B) : <span class="kr">forall</span> <span class="nv">n</span>, vec A n -&gt; vec B n :=
  <span class="kr">fun</span> <span class="nv">n</span> <span class="nv">l</span> =&gt; snd (stepN t l).</span></span></pre><p>To turn this family of components defined by <code class="highlight coq"><span class="n">execN</span> <span class="n">t</span></code> into a causal map, we must also prove the
commuting squares which show that <code class="highlight coq"><span class="n">execN</span> <span class="n">t</span></code> commutes with truncation. Proving this will require
a sort of &quot;eta law&quot; for <code class="highlight coq"><span class="n">execN</span></code> called <code class="highlight coq"><span class="n">execN_snoc</span></code>. In short, this says that
the result of the <code class="highlight coq"><span class="n">n</span><span class="o">+</span><span class="mi">1</span></code>-st component of <code class="highlight coq"><span class="n">execN</span> <span class="n">t</span></code> is just that of the <code class="highlight coq"><span class="n">n</span></code>-th, with one more step of <code class="highlight coq"><span class="n">t</span></code> tacked on at the end.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk21"><span class="kn">Theorem</span> <span class="nf">execN_snoc</span> {<span class="nv">A</span> <span class="nv">B</span>} : <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">x</span>, execN t (S n) (Snoc A l x) = Snoc B (execN t n l) (<span class="kr">let</span> (<span class="nv">t&#39;</span>,_) := stepN t l <span class="kr">in</span> fst (step t&#39; x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : transd A B) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A n)
  (<span class="nv">x</span> : A),
execN t (S n) (Snoc A l x) =
Snoc B (execN t n l)
  (<span class="kr">let</span> (<span class="nv">t&#39;</span>, _) := stepN t l <span class="kr">in</span> fst (step t&#39; x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : transd A B) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A n)
  (<span class="nv">x</span> : A),
execN t (S n) (Snoc A l x) =
Snoc B (execN t n l)
  (<span class="kr">let</span> (<span class="nv">t&#39;</span>, _) := stepN t l <span class="kr">in</span> fst (step t&#39; x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk23"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">execN t (S n) (Snoc A l x) =
Snoc B (execN t n l)
  (<span class="kr">let</span> (<span class="nv">t&#39;</span>, _) := stepN t l <span class="kr">in</span> fst (step t&#39; x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk24"><span class="nb">unfold</span> execN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (stepN t (Snoc A l x)) =
Snoc B (snd (stepN t l))
  (<span class="kr">let</span> (<span class="nv">t&#39;</span>, _) := stepN t l <span class="kr">in</span> fst (step t&#39; x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk25"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  (<span class="kr">let</span> (<span class="nv">t&#39;</span>, l&#39;&#39;) := stepN t l <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">y</span>, t&#39;&#39;) := step t&#39; x <span class="kr">in</span> (t&#39;&#39;, Snoc B l&#39;&#39; y)) =
Snoc B (snd (stepN t l))
  (<span class="kr">let</span> (<span class="nv">t&#39;</span>, _) := stepN t l <span class="kr">in</span> fst (step t&#39; x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk26"><span class="nb">destruct</span> (stepN t l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>vec B n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (<span class="kr">let</span> (<span class="nv">y</span>, t&#39;&#39;) := step t0 x <span class="kr">in</span> (t&#39;&#39;, Snoc B v y)) =
Snoc B (snd (t0, v)) (fst (step t0 x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk27"><span class="nb">destruct</span> (step t0 x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>vec B n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (t1, Snoc B v b) =
Snoc B (snd (t0, v)) (fst (b, t1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk28"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>vec B n</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Snoc B v b = Snoc B v b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk29"><span class="kn">Theorem</span> <span class="nf">execN_caused</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">t</span> : transd A B) : <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec _ (S n)),
  execN t n (truncate l) = truncate (execN t (S n) l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A (S n)),
execN t n (truncate l) = truncate (execN t (S n) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : vec A (S n)),
execN t n (truncate l) = truncate (execN t (S n) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk2b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">execN t n (truncate l) = truncate (execN t (S n) l)</div></blockquote></div></div></small></span></pre><p>We begin by using the <code class="highlight coq"><span class="nb">dependent destruction</span></code> tactic, which uses the fact that <code class="highlight coq"><span class="n">l</span></code> has length at least one to refine our goal to handling the case where <code class="highlight coq"><span class="n">l</span></code> is actually <code class="highlight coq"><span class="n">Snoc</span> <span class="n">l</span> <span class="n">a</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="causal-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk2c"><span class="nb">dependent destruction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">execN t n (truncate (Snoc A l a)) =
truncate (execN t (S n) (Snoc A l a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="causal-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk2d"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">execN t n l = truncate (execN t (S n) (Snoc A l a))</div></blockquote></div></div></small></span></pre><p>We then apply the <code class="highlight coq"><span class="n">execN_snoc</span></code> lemma to massage the <code class="highlight coq"><span class="n">execN</span> <span class="n">t</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">Snoc</span> <span class="n">_</span> <span class="n">l</span> <span class="n">a</span><span class="o">)</span></code> term into a form where we can directly reduce <code class="highlight coq"><span class="n">truncate</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="causal-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk2e"><span class="nb">rewrite</span> execN_snoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">execN t n l =
truncate
  (Snoc B (execN t n l)
     (<span class="kr">let</span> (<span class="nv">t&#39;</span>, _) := stepN t l <span class="kr">in</span> fst (step t&#39; a)))</div></blockquote></div></div></small></span></pre><p>Ignoring the cruft in the second component of the snoc, we note that the RHS is of the form <code class="highlight coq"><span class="n">truncate</span> <span class="o">(</span><span class="n">Snoc</span> <span class="n">_</span> <span class="o">(</span><span class="n">execN</span> <span class="n">t</span> <span class="n">l</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span></code>, which directly reduces by one use of <code class="highlight coq"><span class="nb">cbn</span></code> to <code class="highlight coq"><span class="n">execN</span> <span class="n">t</span> <span class="n">l</span></code>, as required.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="causal-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk2f"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t</var><span class="hyp-type"><b>: </b><span>transd A B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>vec A n</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">execN t n l = execN t n l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>With components and proofs in hand, we can package them together to get a function <code class="highlight coq"><span class="n">transdToCausal</span> <span class="o">:</span> <span class="n">transd</span> <span class="n">A</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">causal</span> <span class="n">A</span> <span class="n">B</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transdToCausal</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">t</span> : transd A B) : causal A B :=
  mkCausal _ _ (execN t) (execN_caused t).</span></span></pre><p>Of course, we can also go backwards: causal maps define transducers. This translation works essentially
the same way as the interpretation of causal functions as stream maps: we accumulate the previously-seen values,
and apply the <code class="highlight coq"><span class="n">n</span><span class="o">+</span><span class="mi">1</span></code>-st component after <code class="highlight coq"><span class="n">n</span></code> accumulated values to get the next.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">causalToTransdAux</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">n</span> : nat} (<span class="nv">c</span> : causal A B) (<span class="nv">l</span> : vec A n) : transd A B :=
  T _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; 
           <span class="kr">let</span> <span class="nv">y</span> := causalApplySnoc c l x <span class="kr">in</span>
           (y, causalToTransdAux c (Snoc _ l x))
        ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">causalToTransd</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">c</span> : causal A B) : transd A B :=
  causalToTransdAux c (Empty _).</span></span></pre></div>
<div class="section" id="what-s-left">
<h1>What's Left</h1>
<p>Of course, these maps back and forth create natural proof obligations. In order to show that causal maps
and transducers define the same set of stream functions, it remains to show the following:</p>
<blockquote>
<ol class="arabic simple">
<li>The <code class="highlight coq"><span class="n">causalToTransd</span></code> and <code class="highlight coq"><span class="n">transdToCausal</span></code> functions are (weakly) inverses, up to suitable equivalence relations on
<code class="highlight coq"><span class="n">causal</span> <span class="n">A</span> <span class="n">B</span></code> and <code class="highlight coq"><span class="n">transd</span> <span class="n">A</span> <span class="n">B</span></code>.</li>
<li>Equivalent causal functions and equivalent trandsucers are interpreted as equivalent stream functions: i.e. the functions
<code class="highlight coq"><span class="n">interpCausal</span></code> and <code class="highlight coq"><span class="n">interpTransd</span></code> are congruences.</li>
</ol>
</blockquote>
<p>We define these equivalence relations and theorems below ‚Äì I have yet to prove them.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">stream_eq</span> {<span class="nv">A</span>} : stream A -&gt; stream A -&gt; <span class="kt">Prop</span> :=
| Eq_SCons : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">s&#39;</span>, stream_eq s s&#39; -&gt; stream_eq (SCons _ x s) (SCons _ x s&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">causal_eq</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">c</span> : causal A B) (<span class="nv">c&#39;</span> : causal A B) :=
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">l</span>, f _ _ c n l = f _ _ c&#39; n l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">transd_eq</span> {<span class="nv">A</span> <span class="nv">B</span>} : transd A B -&gt; transd A B -&gt; <span class="kt">Prop</span> :=
| Eq_T : <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">f&#39;</span>, (<span class="kr">forall</span> (<span class="nv">x</span> : A), (fst (f x)) = (fst (f&#39; x)) /\ transd_eq (snd (f x)) (snd (f&#39; x))) -&gt; transd_eq (T _ _ f) (T _ _ f&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk30"><span class="kn">Theorem</span> <span class="nf">causalToTransdAndBack</span> {<span class="nv">A</span> <span class="nv">B</span>} :
  <span class="kr">forall</span> (<span class="nv">c</span> : causal A B), causal_eq c (transdToCausal (causalToTransd c)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : causal A B,
causal_eq c (transdToCausal (causalToTransd c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> : causal A B,
causal_eq c (transdToCausal (causalToTransd c))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk32"><span class="kn">Theorem</span> <span class="nf">transdToCausalAndBack</span> {<span class="nv">A</span> <span class="nv">B</span>} :
  <span class="kr">forall</span> (<span class="nv">t</span> : transd A B), transd_eq t (causalToTransd (transdToCausal t)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : transd A B,
transd_eq t (causalToTransd (transdToCausal t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : transd A B,
transd_eq t (causalToTransd (transdToCausal t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk34"><span class="kn">Theorem</span> <span class="nf">interpCausal_cong</span> {<span class="nv">A</span> <span class="nv">B</span>} :
  <span class="kr">forall</span> (<span class="nv">c</span> <span class="nv">c&#39;</span> : causal A B), causal_eq c c&#39; -&gt; <span class="kr">forall</span> <span class="nv">s</span>, stream_eq (interpCausal c s) (interpCausal c&#39; s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> <span class="nv">c&#39;</span> : causal A B,
causal_eq c c&#39; -&gt;
<span class="kr">forall</span> <span class="nv">s</span> : stream A,
stream_eq (interpCausal c s) (interpCausal c&#39; s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">c</span> <span class="nv">c&#39;</span> : causal A B,
causal_eq c c&#39; -&gt;
<span class="kr">forall</span> <span class="nv">s</span> : stream A,
stream_eq (interpCausal c s) (interpCausal c&#39; s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk36"><span class="kn">Theorem</span> <span class="nf">interpTransd_cong</span> {<span class="nv">A</span> <span class="nv">B</span>} :
  <span class="kr">forall</span> (<span class="nv">t</span> <span class="nv">t&#39;</span> : transd A B), transd_eq t t&#39; -&gt; <span class="kr">forall</span> <span class="nv">s</span>, stream_eq (interpTransd t s) (interpTransd t&#39; s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t&#39;</span> : transd A B,
transd_eq t t&#39; -&gt;
<span class="kr">forall</span> <span class="nv">s</span> : stream A,
stream_eq (interpTransd t s) (interpTransd t&#39; s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="causal-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="causal-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> <span class="nv">t&#39;</span> : transd A B,
transd_eq t t&#39; -&gt;
<span class="kr">forall</span> <span class="nv">s</span> : stream A,
stream_eq (interpTransd t s) (interpTransd t&#39; s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>For the curious: by endowing <span class="math">\(2\)</span> with the discrete topology and <span class="math">\(2^\omega\)</span> with the product topology, the computable functions <span class="math">\(2^\omega \to 2^\omega\)</span> are continuous.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td>We will not be discussing coinduction or cofixpoints in this document, but the unfamiliar reader can safely ignore this detail, and treat the coinductive definitions as just special syntax for defining datatypes that have infinite values.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="reflections-on-literate-programming-in-coq">
<h1>Reflections on Literate Programming in Coq</h1>
<p>This document was written as my final project in Prof. Andrew Head's course
&quot;Live and Literate Programming&quot; in Fall 2022. After a semester of studying literate programing,
this case study left me with a few take-aways and recommendations for future designers of literate programming
tools for theorem provers like Coq.</p>
<ul class="simple">
<li>Literate programming tools should never enforce that the code in the woven
(pdf/html output) view appear in the same order as it does in the original code
view. Unfortunately, Alectryon requires definition-order documents. I would much
prefer something like Torii where I can weave the code together in an order that
makes pedagogical sense, but does not necessarily pass the proof checker. The
writing style in this document is severely hampered by the need to present
everything before it appears.</li>
<li>Alectryon does not permit the hiding of definition bodies. Many of the theorems
and definitions that appear in this document are &quot;standard&quot; in the sense that
they require little mathematical insight to prove or develop. Some examples
include the <code class="highlight coq"><span class="n">cons</span></code> and <code class="highlight coq"><span class="n">tail</span></code> functions on snoc-lists, as well as the
compatability theorems like <code class="highlight coq"><span class="n">cons_snoc</span></code> or <code class="highlight coq"><span class="n">truncate_cons</span></code>. Unfortunately,
Alectryon requires that if the statements and type signatures of these theorems
and definitions are to be shown in the document, then their proofs and bodies
must also be shown. This is significant cruft that draws the reader away from
their real task understanding the <em>imporant</em> theorems and definitions.</li>
<li>It is very difficult to write an Alectryon document without the use of the
library's custom emacs-based editing tool which allows one to fluidly change
back and forth between code-primary and markdown-primary views. The philosophy
of the tool is that neither view should be considered &quot;primary&quot;, and that there
is no third view that the code and markdown compile from. In practice, however,
without the use of the emacs extension (or emacs altogether), the Coq format
quickly becomes primary.</li>
</ul>
</div>
</div>
</div></body>
</html>
